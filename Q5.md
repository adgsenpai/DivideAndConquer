# Q5. Quickselect (k-th order statistic)

## (a) Pseudocode for randomized Quickselect

```
QUICKSELECT(A, left, right, k):
    // Base cases
    if left == right:
        return A[left]
    
    // Choose random pivot and partition
    pivotIndex = RANDOM(left, right)
    pivotIndex = PARTITION(A, left, right, pivotIndex)
    
    // Pivot is now at its final sorted position
    if k == pivotIndex:
        return A[k]
    else if k < pivotIndex:
        return QUICKSELECT(A, left, pivotIndex - 1, k)
    else:
        return QUICKSELECT(A, pivotIndex + 1, right, k)

PARTITION(A, left, right, pivotIndex):
    pivotValue = A[pivotIndex]
    swap A[pivotIndex] with A[right]  // move pivot to end
    
    storeIndex = left
    for i = left to right - 1:
        if A[i] < pivotValue:
            swap A[i] with A[storeIndex]
            storeIndex++
    
    swap A[storeIndex] with A[right]  // move pivot to final position
    return storeIndex
```

**Base cases:**
1. When `left == right`: single element, return it
2. When `k == pivotIndex`: pivot is at position k, return it

---

## (b) Expected time recurrence and solution

**Recurrence (expected):**
- Best/Average case: T(n) = T(n/2) + O(n)
- The partition takes O(n) time
- On average, we recurse on half the array

**Solution using Master Theorem:**
- T(n) = T(n/2) + cn for some constant c
- This is case 3 of Master Theorem: f(n) = cn dominates
- T(n) = O(n)

**Detailed analysis:**
Expected time: E[T(n)] = E[partition cost] + E[recursive cost]

The partition always costs O(n).

For the recursive cost, if the pivot is the j-th smallest element:
- Probability pivot is j-th = 1/n
- If j ≤ k: recurse on right subarray of size (n-j)
- If j > k: recurse on left subarray of size (j-1)

E[T(n)] = n + (1/n) × Σ_{j=1}^{n} T(max(j-1, n-j))
        ≤ n + (2/n) × Σ_{j=⌈n/2⌉}^{n} T(j)

Solving this recurrence gives **T(n) = O(n)** expected time.

**Intuition:** We eliminate a constant fraction of elements in expectation at each step, leading to:
n + n/2 + n/4 + n/8 + ... = O(n)

---

## (c) Example: Find median of [12, 7, 3, 9, 14, 1, 10]

Array: [12, 7, 3, 9, 14, 1, 10], n = 7, k = 3 (0-indexed median)

**Step 1:** Pivot = 9 (randomly chosen at index 3)
- Partition around 9: [7, 3, 1, **9**, 14, 12, 10]
- Pivot ends at index 3
- k = 3, found! Return 9

Alternative trace (different random pivot):

**Step 1:** Pivot = 12 (index 0)
- Partition: [7, 3, 9, 1, 10, **12**, 14]
- Pivot at index 5
- k = 3 < 5, recurse left on [7, 3, 9, 1, 10]

**Step 2:** Subarray [7, 3, 9, 1, 10], k = 3
- Pivot = 7 (index 0 of subarray)
- Partition: [3, 1, **7**, 9, 10]
- Pivot at index 2 (global index 2)
- k = 3 > 2, recurse right on [9, 10]

**Step 3:** Subarray [9, 10], k = 3 (global), local k = 0
- Pivot = 9
- Partition: [**9**, 10]
- Pivot at index 3 (global)
- k = 3, found! Return 9

**Result:** Median = 9 ✓

Sorted array would be: [1, 3, 7, **9**, 10, 12, 14]
