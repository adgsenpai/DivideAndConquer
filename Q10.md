# Q10. Strassen's Matrix Multiplication (divide-and-conquer with algebraic trick)

## (a) Recurrence and solution

**Classical matrix multiplication:** C = A × B (n × n matrices)
- Direct: 3 nested loops → Θ(n³) multiplications and Θ(n³) additions

**Strassen's Algorithm:**

**Divide:** Split n×n matrices into 4 (n/2)×(n/2) submatrices:
```
A = [A11  A12]    B = [B11  B12]
    [A21  A22]        [B21  B22]
```

**Conquer:** Compute 7 products (instead of 8):
```
M1 = (A11 + A22)(B11 + B22)
M2 = (A21 + A22)B11
M3 = A11(B12 - B22)
M4 = A22(B21 - B11)
M5 = (A11 + A12)B22
M6 = (A21 - A11)(B11 + B12)
M7 = (A12 - A22)(B21 + B22)
```

**Combine:** Compute result submatrices:
```
C11 = M1 + M4 - M5 + M7
C12 = M3 + M5
C21 = M2 + M4
C22 = M1 - M2 + M3 + M6
```

**Recurrence for multiplications:**
```
M(n) = 7M(n/2) + O(n²)    (7 recursive multiplications, O(n²) additions)
M(1) = 1                   (base case)
```

**Solution using Master Theorem:**
- a = 7, b = 2, f(n) = O(n²)
- n^(log_b a) = n^(log_2 7) ≈ n^2.807
- f(n) = O(n²) < O(n^2.807) → Case 1
- **M(n) = Θ(n^(log_2 7)) ≈ Θ(n^2.807)**

**Recurrence for additions:**
```
A(n) = 7A(n/2) + Θ(n²)
```
Also gives **A(n) = Θ(n^(log_2 7))**

**Note:** Total operations = M(n) + A(n) = Θ(n^(log_2 7))

---

## (b) Computation for n = 8

**Classical multiplication (n³):**
- Scalar multiplications: n³ = 8³ = **512**
- Scalar additions: n²(n-1) = 64 × 7 = **448**

**Strassen's algorithm:**

For n = 8 (one level of recursion to n = 4, then to n = 2, then to n = 1):

**Recursion levels:**
- Level 0 (n=8): 7⁰ = 1 call
- Level 1 (n=4): 7¹ = 7 calls  
- Level 2 (n=2): 7² = 49 calls
- Level 3 (n=1): 7³ = 343 calls (base cases)

**Total scalar multiplications:**
M(8) = 7³ = **343**

**Additions count (approximate):**
At each level k (n = 8/2^k):
- Number of calls: 7^k
- Additions per call: O((8/2^k)²)

Total additions:
A(8) = Σ(k=0 to 3) 7^k × c × (8/2^k)²
     = c × 64 × Σ(k=0 to 3) (7/4)^k
     = c × 64 × (1 + 7/4 + 49/16 + 343/64)
     ≈ c × 64 × 6.8
     ≈ **435** (with appropriate constant c)

**Comparison:**
- Classical: 512 multiplications, 448 additions
- Strassen: 343 multiplications (~33% fewer), ~435 additions
- **Multiplication reduction: 512 → 343 (saves 169 operations)**

---

## (c) Practical considerations and crossover point

**When Strassen becomes beneficial:**

1. **Crossover size (n₀):**
   - For n < n₀: classical multiplication faster (lower constants)
   - For n ≥ n₀: Strassen faster (better asymptotic complexity)
   - Typical n₀ ≈ 64-128 (depends on implementation and hardware)

2. **Why not always use Strassen?**

**Implementation concerns:**

**1. Numerical stability:**
   - More subtractions → potential for cancellation errors
   - Classical multiplication: no subtractions, more stable
   - Critical in numerical applications (scientific computing)

**2. Cache efficiency:**
   - Classical multiplication: simple, cache-friendly access patterns
   - Strassen: irregular access, many temporary matrices
   - Small n: cache effects dominate, classical wins
   - Large n: asymptotic advantage overcomes cache overhead

**3. Memory overhead:**
   - Strassen requires O(n²) temporary storage for submatrices
   - Classical can be done with minimal extra space
   - Embedded systems: memory constraints favor classical

**4. Constant factors:**
   - Strassen has larger hidden constants
   - 7 multiplications + ~18 additions/subtractions vs 8 multiplications + 4 additions
   - Break-even when n² term dominates

**5. Parallelization:**
   - Classical: easily parallelized (independent dot products)
   - Strassen: dependencies between submatrices complicate parallelization

**6. Non-power-of-two sizes:**
   - Strassen assumes n = 2^k
   - Padding needed for arbitrary n → wasted computation
   - Classical works for any n without modification

**Practical recommendations:**
- Use classical for n < 64-128
- Use Strassen for large matrices (n > 512) in non-critical applications
- Consider Strassen variants (Winograd, optimized recursion cutoffs)
- For production: libraries like BLAS use hybrid approaches
- For GPU: classical often preferred due to better memory patterns

**Theoretical vs Practical:**
- Theoretically: Θ(n^2.807) beats Θ(n³)
- Practically: n₀ is large, and numerical stability/cache/constants matter
- Modern approach: Strassen + cutoff to optimized classical (similar to quicksort hybrid)
