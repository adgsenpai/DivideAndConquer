### (a) Trace of insertion sort on `A = [6, 2, 9, 1, 5, 3]`

We use the standard insertion sort:

```
for i = 1..n-1:
    key = A[i]
    j = i - 1
    while j >= 0 and A[j] > key:
        A[j+1] = A[j]
        j = j - 1
    A[j+1] = key
```

**i = 1, key = 2**
Shifts: `6 →`
Array during shifts: `[6, 6, 9, 1, 5, 3]` → place `2` at index 0
**State after insertion:** `[2, 6, 9, 1, 5, 3]`

**i = 2, key = 9**
No shifts (since `6 ≤ 9`)
**State after insertion:** `[2, 6, 9, 1, 5, 3]`

**i = 3, key = 1**
Shifts: `9 →`, `6 →`, `2 →`
Array during shifts:
`[2, 6, 9, 9, 5, 3]` → `[2, 6, 6, 9, 5, 3]` → `[2, 2, 6, 9, 5, 3]` → place `1` at index 0
**State after insertion:** `[1, 2, 6, 9, 5, 3]`

**i = 4, key = 5**
Shifts: `9 →`, `6 →`
Array during shifts:
`[1, 2, 6, 9, 9, 3]` → `[1, 2, 6, 6, 9, 3]` → place `5` at index 2
**State after insertion:** `[1, 2, 5, 6, 9, 3]`

**i = 5, key = 3**
Shifts: `9 →`, `6 →`, `5 →`
Array during shifts:
`[1, 2, 5, 6, 9, 9]` → `[1, 2, 5, 6, 6, 9]` → `[1, 2, 5, 5, 6, 9]` → place `3` at index 2
**Final sorted array:** `[1, 2, 3, 5, 6, 9]`

---

### (b) Inner while-loop invariant and correctness

Let the inner loop be:

```
while j >= 0 and A[j] > key:
    A[j+1] = A[j]
    j = j - 1
A[j+1] = key
```

**Invariant (at the start of each while-loop iteration):**

1. The segment `A[j+1 .. i-1]` contains exactly those elements from the original `A[0 .. i-1]` that are **strictly greater than** `key`, and they have been shifted one position to the right (preserving their relative order).
2. Every element in `A[0 .. j]` is **≤ key** (this is vacuously true when `j = i-1` at the very first check; once a shift happens, it continues to hold by construction).
3. Positions `A[i .. n-1]` are untouched.

**Initialization:** Before the first test, `A[i] = key` and `A[i-1]` is the only candidate compared to `key`. Trivially, the set of elements known to be `> key` is empty and the invariant holds.

**Maintenance:** If `A[j] > key`, we assign `A[j+1] = A[j]` and decrease `j`. This keeps all elements greater than `key` in `A[j+1 .. i-1]` shifted one step to the right, and the region `A[0 .. j]` remains elements not yet known to be `> key`—in particular, after the loop condition re-checks, it is still true that everything in `A[j]` that would violate `≤ key` gets shifted, preserving the invariant.

**Termination:** The loop stops when either `j < 0` or `A[j] ≤ key`. At that point, by the invariant:

* All elements in `A[j+1 .. i-1]` are strictly greater than `key`;
* All elements in `A[0 .. j]` are ≤ `key`.
  Placing `key` at `A[j+1]` yields `A[0 .. i]` sorted.

**Outer loop correctness:** By induction on `i`, at the end of each outer iteration the prefix `A[0 .. i]` is sorted and is a permutation of the first `i+1` original elements. For `i = n-1` we obtain the whole array sorted.

**Termination via a “decrease-by-1” variant:**
Inside the inner loop, the integer `j` strictly decreases by exactly 1 each iteration and is bounded below by `-1`. Thus the loop must terminate. (This is the “decrease by 1” measure.)

---

### (c) Tight Θ-bounds and witnessing input families

* **Best case:** `Θ(n)` comparisons/moves.
  **When:** The array is already nondecreasing (sorted).
  **Reason:** For each `i`, the inner while fails immediately (`A[j] ≤ key`), doing O(1) work.
  **Family:** `A = [1, 2, 3, …, n]`.

* **Average case:** `Θ(n^2)` expected time.
  **When:** Over a uniformly random permutation.
  **Reason:** Expected number of inversions in a random permutation is `n(n−1)/4`, and insertion sort’s work is proportional to the number of inversions (each inversion causes one shift/comparison chain), yielding `Θ(n^2)` in expectation.
  **Family:** All `n!` permutations with the uniform distribution.

* **Worst case:** `Θ(n^2)` time.
  **When:** The array is strictly decreasing.
  **Reason:** For each `i`, the key is smaller than all `i` elements in the sorted prefix, causing `i` shifts: total `∑_{i=1}^{n-1} i = n(n−1)/2 = Θ(n^2)`.
  **Family:** `A = [n, n−1, …, 2, 1]`.

**Operation counts (typical):**

* Best case comparisons: `n−1`; moves: `n−1` writes of `key` (no shifts).
* Worst case comparisons & shifts: about `n(n−1)/2` each (up to constant/additive lower-order terms).
* Average case: about half the worst-case leading term (still `Θ(n^2)`).
