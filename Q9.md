# Q9. Closest Pair of Points in the Plane (divide-and-conquer)

## (a) Split-Recur-Merge algorithm and time bound

**Algorithm Outline:**

1. **Preprocessing:** Sort points by x-coordinate: O(n log n)

2. **Recursive divide-and-conquer:**
   ```
   CLOSEST_PAIR(P, sorted by x):
       if |P| ≤ 3:
           return brute force minimum distance
       
       // Divide
       Split P at median x into P_L and P_R
       
       // Conquer
       δ_L = CLOSEST_PAIR(P_L)
       δ_R = CLOSEST_PAIR(P_R)
       δ = min(δ_L, δ_R)
       
       // Merge (straddle check)
       δ_straddle = CHECK_STRIP(P, median_x, δ)
       
       return min(δ, δ_straddle)
   ```

3. **Strip check (merge step):**
   - Consider strip of width 2δ around dividing line
   - For each point in strip (sorted by y):
     - Check only next ~7 points (by packing lemma)
   - Time: O(n) for the strip

**Recurrence:**
```
T(n) = 2T(n/2) + O(n)    (assuming presorted by y, or we sort strip)
T(1) = O(1)
```

**Solution:** T(n) = O(n log n) by Master Theorem (Case 2)

**Total time bound:** O(n log n)
- Preprocessing: O(n log n) to sort by x
- Recursive calls: O(n log n)
- **Overall: O(n log n)**

---

## (b) Packing lemma proof

**Packing Lemma:** In the strip of width 2δ around the dividing line, when points are sorted by y-coordinate, each point needs to check at most 7 subsequent points.

**Proof:**

**Setup:**
- Strip S = {(x, y) : |x - median_x| ≤ δ}
- Points sorted by y-coordinate
- We know: no two points on same side are closer than δ

**Key observation:**
Consider a point p in the strip. We need to check points q where:
- q is within distance δ of p
- q has larger y-coordinate than p

**Geometric constraint:**
Points within distance δ of p lie in circle of radius δ centered at p.
We only care about points in the strip with larger y-coordinate.

**Divide strip into left half (x < median_x) and right half (x ≥ median_x):**
- Each half has width δ
- Within each half, no two points are closer than δ (by recursion)

**Packing argument:**
Consider rectangle R = [median_x - δ, median_x + δ] × [p.y, p.y + δ]
- R has dimensions 2δ × δ
- Divide R into 8 squares of size δ/2 × δ/2
- Each square can contain at most 1 point (otherwise distance < δ/√2 < δ)
- Point p occupies one square
- At most 7 other points in remaining squares
- Only need to check these 7 points

**Alternate bound (tighter):**
- Using more careful geometry: at most 5 points need to be checked
- Some implementations use 5 or 6 as the constant

**Conclusion:** Each point checks O(1) subsequent points → strip scan is O(n) ✓

---

## (c) Example application

**Points:** {(0,0), (1,2), (2,1), (3,3), (4,0), (5,2)}

**Step 1:** Sort by x: already sorted ✓
Sort by y: (0,0), (4,0), (2,1), (1,2), (5,2), (3,3)

**Step 2:** Divide at median x = 2.5
- Left: {(0,0), (1,2), (2,1)}
- Right: {(3,3), (4,0), (5,2)}

**Step 3:** Recurse on left half {(0,0), (1,2), (2,1)}
- Brute force (size 3):
  - d(0,0)-(1,2) = √5 ≈ 2.236
  - d(0,0)-(2,1) = √5 ≈ 2.236
  - d(1,2)-(2,1) = √2 ≈ 1.414
- δ_L = √2 ≈ 1.414

**Step 4:** Recurse on right half {(3,3), (4,0), (5,2)}
- Brute force (size 3):
  - d(3,3)-(4,0) = √10 ≈ 3.162
  - d(3,3)-(5,2) = √5 ≈ 2.236
  - d(4,0)-(5,2) = √5 ≈ 2.236
- δ_R = √5 ≈ 2.236

**Step 5:** δ = min(δ_L, δ_R) = √2 ≈ 1.414

**Step 6:** Check strip [2.5 - √2, 2.5 + √2] ≈ [1.086, 3.914]
Points in strip (sorted by y): (2,1), (1,2), (3,3)

**Comparisons in strip:**
- Point (2,1): check (1,2) and (3,3)
  - d(2,1)-(1,2) = √2 ≈ 1.414 (equals current δ)
  - d(2,1)-(3,3) = √5 ≈ 2.236 > δ
- Point (1,2): check (3,3)
  - d(1,2)-(3,3) = √5 ≈ 2.236 > δ
- Point (3,3): no more points above

**Result:** Closest pair distance = √2 ≈ 1.414
Closest pairs: {(1,2), (2,1)} or {(0,0), (1,2)} or {(0,0), (2,1)} - wait, let me recalculate:

Actually:
- d(1,2)-(2,1) = √((1-2)² + (2-1)²) = √(1 + 1) = √2 ✓

**Final answer:** Minimum distance = √2, achieved by points (1,2) and (2,1)
