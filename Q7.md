# Q7. Johnson-Trotter Permutations (decrease by 1 with minimal change)

## (a) Mobile element definition and first six permutations

**Mobile Element Definition:**
An element is **mobile** if it has an arrow pointing to a smaller adjacent element.
- Element with left arrow (←) is mobile if its left neighbor is smaller
- Element with right arrow (→) is mobile if its right neighbor is smaller

**Algorithm:**
1. Start with all elements pointing left: n←, (n-1)←, ..., 2←, 1←
2. Repeat:
   - Find the largest mobile element
   - Swap it with the adjacent element in the direction of its arrow
   - Reverse the direction of all elements larger than it

**First six permutations of {1, 2, 3, 4}:**

**Perm 1:** 1← 2← 3← 4←
- Largest mobile: 4 (points left at 3, which is smaller)
- Swap 4 with 3

**Perm 2:** 1← 2← 4← 3←
- Largest mobile: 4 (points left at 2, which is smaller)
- Swap 4 with 2

**Perm 3:** 1← 4← 2← 3←
- Largest mobile: 4 (points left at 1, which is smaller)
- Swap 4 with 1

**Perm 4:** 4← 1← 2← 3←
- 4 has no smaller left neighbor → not mobile
- Largest mobile: 3 (points left at 2, which is smaller)
- Swap 3 with 2, reverse direction of 4

**Perm 5:** 4→ 1← 3← 2←
- Largest mobile: 4 (points right at 1, which is smaller)
- Swap 4 with 1

**Perm 6:** 1← 4→ 3← 2←
- Largest mobile: 4 (points right at 3, which is smaller)
- Swap 4 with 3

Continue this process to generate all 24 permutations...

**Arrow directions after each step:**
1. 1← 2← 3← 4← (start)
2. 1← 2← 4← 3← (swapped 4 and 3)
3. 1← 4← 2← 3← (swapped 4 and 2)
4. 4← 1← 2← 3← (swapped 4 and 1)
5. 4→ 1← 3← 2← (swapped 3 and 2, reversed 4)
6. 1← 4→ 3← 2← (swapped 4 and 1)

---

## (b) Time complexity and optimality

**Time Complexity:** Θ(n! × n)

**Analysis:**
- Total permutations generated: n!
- Each transition requires:
  - Finding largest mobile element: O(n)
  - Swapping: O(1)
  - Reversing directions: O(n) in worst case
- Total: O(n! × n)

**Space for output:** O(n! × n)
- Must output n! permutations
- Each permutation has n elements

**Optimality:**

The algorithm is **optimal with respect to output size** because:

1. **Output requirement:** Must generate all n! permutations of n elements
   - Output size is Ω(n! × n) - cannot avoid this

2. **Transitions:** Algorithm makes exactly n! - 1 swaps
   - Each permutation (except first) is reached by one swap
   - This is **minimal** - you need at least n! - 1 transitions

3. **Per-permutation work:** Each permutation requires O(n) work to:
   - Find next mobile element
   - Perform swap
   - Update directions
   
4. **Optimality argument:**
   - Lower bound: Ω(n! × n) just to write the output
   - Upper bound: O(n! × n) for Johnson-Trotter
   - Therefore, it's optimal: Θ(n! × n)

**Minimal-change property:**
- Consecutive permutations differ by **exactly one swap** (adjacent elements)
- This is optimal - you cannot change fewer than 1 element
- Gray code for permutations

**Advantages:**
- Generates permutations in a specific order (lexicographic-like)
- Each permutation differs minimally from previous (one swap)
- No recursion stack needed (can be implemented iteratively)
- Useful when switching between permutations has high cost
