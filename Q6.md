# Q6. Generating the Powerset (decrease by 1) and Gray Code

## (a) Recursive algorithm for powerset P(S)

**Algorithm:**
For a set S = {a, b, c, d}, generate P(S) by:
1. Base case: P(∅) = {∅}
2. Recursive case: P(S) = P(S - {x}) ∪ {T ∪ {x} : T ∈ P(S - {x})}
   - Remove one element x from S
   - Recursively generate P(S - {x})
   - Return all subsets without x, plus all subsets with x added

**Generating P({a, b, c, d}):**

Remove 'd', recursively get P({a, b, c}):
- Subsets without d: all from P({a, b, c})
- Subsets with d: add d to each subset from P({a, b, c})

**First 10 subsets produced (adding elements one at a time):**

1. {} (empty set)
2. {a}
3. {b}
4. {a, b}
5. {c}
6. {a, c}
7. {b, c}
8. {a, b, c}
9. {d}
10. {a, d}

**Complete powerset (16 subsets):**
1. {}
2. {a}
3. {b}
4. {a, b}
5. {c}
6. {a, c}
7. {b, c}
8. {a, b, c}
9. {d}
10. {a, d}
11. {b, d}
12. {a, b, d}
13. {c, d}
14. {a, c, d}
15. {b, c, d}
16. {a, b, c, d}

**Time complexity:** O(n × 2^n) - generate 2^n subsets, each taking O(n) to construct

---

## (b) Binary Reflected Gray Code enumeration

**Gray Code property:** Consecutive codewords differ by exactly one bit.

**Algorithm to enumerate powerset via Gray Code:**
1. Map each subset to a binary number (bit i = 1 if element i is in subset)
2. Traverse binary strings in Gray code order
3. Each transition flips exactly one bit → adds/removes exactly one element

**Gray Code sequence for n=4:**
```
0000 → {}
0001 → {d}
0011 → {c, d}
0010 → {c}
0110 → {b, c}
0111 → {b, c, d}
0101 → {b, d}
0100 → {b}
1100 → {a, b}
1101 → {a, b, d}
1111 → {a, b, c, d}
1110 → {a, b, c}
1010 → {a, c}
1011 → {a, c, d}
1001 → {a, d}
1000 → {a}
```

**Proof of one-bit flip property:**

**Construction:** Binary Reflected Gray Code for n bits:
- Base case (n=1): [0, 1]
- Recursive case: 
  - Gray_n = [0 + Gray_{n-1}, 1 + reverse(Gray_{n-1})]
  - Prefix first half with 0, second half with 1
  - Reverse the second half before prefixing

**Proof by induction:**
- **Base case (n=1):** [0, 1] - consecutive codes differ by 1 bit ✓
- **Inductive step:** Assume Gray_{n-1} has one-bit-flip property
  - Within first half (0-prefixed): consecutive codes differ by 1 bit (by IH)
  - Within second half (1-prefixed, reversed): consecutive codes differ by 1 bit (by IH)
  - **Transition from first to second half:**
    - Last of first half: 0 + last code of Gray_{n-1}
    - First of second half: 1 + last code of Gray_{n-1} (reversed means last becomes first)
    - These differ only in the leading bit ✓
  - **Wrap-around (optional):** First (0 + first of Gray_{n-1}) and last (1 + first of Gray_{n-1}) differ by 1 bit ✓

**Gray Code generation formula:**
- G(i) = i ⊕ (i >> 1) (XOR of i with i right-shifted by 1)

This ensures consecutive Gray codes differ by exactly one bit.
